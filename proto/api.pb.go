// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api.proto

/*
	Package busapi is a generated protocol buffer package.

	It is generated from these files:
		api.proto

	It has these top-level messages:
		AnalyserRequest
		AnalyserResponse
		ScanRequest
		ScanResponse
		ScanCompleted
		JobStatus
*/
package busapi

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Common request codes
type ResultCode int32

const (
	ResultCode_OK   ResultCode = 0
	ResultCode_FAIL ResultCode = 1
)

var ResultCode_name = map[int32]string{
	0: "OK",
	1: "FAIL",
}
var ResultCode_value = map[string]int32{
	"OK":   0,
	"FAIL": 1,
}

func (x ResultCode) String() string {
	return proto.EnumName(ResultCode_name, int32(x))
}
func (ResultCode) EnumDescriptor() ([]byte, []int) { return fileDescriptorApi, []int{0} }

// Analyzer Status
type Status int32

const (
	Status_READY     Status = 0
	Status_PENDING   Status = 1
	Status_WAITING   Status = 2
	Status_SCANNING  Status = 3
	Status_ANALYZING Status = 4
	Status_TIMEOUT   Status = 14
	Status_ERROR     Status = 15
)

var Status_name = map[int32]string{
	0:  "READY",
	1:  "PENDING",
	2:  "WAITING",
	3:  "SCANNING",
	4:  "ANALYZING",
	14: "TIMEOUT",
	15: "ERROR",
}
var Status_value = map[string]int32{
	"READY":     0,
	"PENDING":   1,
	"WAITING":   2,
	"SCANNING":  3,
	"ANALYZING": 4,
	"TIMEOUT":   14,
	"ERROR":     15,
}

func (x Status) String() string {
	return proto.EnumName(Status_name, int32(x))
}
func (Status) EnumDescriptor() ([]byte, []int) { return fileDescriptorApi, []int{1} }

// Bitmask to select requested scanners
type Scanner int32

const (
	Scanner_NONE       Scanner = 0
	Scanner_HARVESTER  Scanner = 1
	Scanner_SPIDERFOOT Scanner = 2
)

var Scanner_name = map[int32]string{
	0: "NONE",
	1: "HARVESTER",
	2: "SPIDERFOOT",
}
var Scanner_value = map[string]int32{
	"NONE":       0,
	"HARVESTER":  1,
	"SPIDERFOOT": 2,
}

func (x Scanner) String() string {
	return proto.EnumName(Scanner_name, int32(x))
}
func (Scanner) EnumDescriptor() ([]byte, []int) { return fileDescriptorApi, []int{2} }

type AnalyserRequest struct {
	// Domain parameter to be scanned
	Domain string `protobuf:"bytes,1,opt,name=domain,proto3" json:"domain,omitempty"`
	// Bitmask of "Scanner" enum which enables certain scanners
	Scanner uint32 `protobuf:"varint,2,opt,name=scanner,proto3" json:"scanner,omitempty"`
}

func (m *AnalyserRequest) Reset()                    { *m = AnalyserRequest{} }
func (m *AnalyserRequest) String() string            { return proto.CompactTextString(m) }
func (*AnalyserRequest) ProtoMessage()               {}
func (*AnalyserRequest) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{0} }

func (m *AnalyserRequest) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *AnalyserRequest) GetScanner() uint32 {
	if m != nil {
		return m.Scanner
	}
	return 0
}

type AnalyserResponse struct {
	// Well - the return code
	Code ResultCode `protobuf:"varint,1,opt,name=code,proto3,enum=busapi.ResultCode" json:"code,omitempty"`
	// Unique ID for this analyser run
	Id string `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *AnalyserResponse) Reset()                    { *m = AnalyserResponse{} }
func (m *AnalyserResponse) String() string            { return proto.CompactTextString(m) }
func (*AnalyserResponse) ProtoMessage()               {}
func (*AnalyserResponse) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{1} }

func (m *AnalyserResponse) GetCode() ResultCode {
	if m != nil {
		return m.Code
	}
	return ResultCode_OK
}

func (m *AnalyserResponse) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type ScanRequest struct {
	// ID of the calling analyzer run
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Domain parameter to be scanned
	Domain string `protobuf:"bytes,2,opt,name=domain,proto3" json:"domain,omitempty"`
}

func (m *ScanRequest) Reset()                    { *m = ScanRequest{} }
func (m *ScanRequest) String() string            { return proto.CompactTextString(m) }
func (*ScanRequest) ProtoMessage()               {}
func (*ScanRequest) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{2} }

func (m *ScanRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ScanRequest) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

type ScanResponse struct {
	// Well - the return code
	Code ResultCode `protobuf:"varint,1,opt,name=code,proto3,enum=busapi.ResultCode" json:"code,omitempty"`
}

func (m *ScanResponse) Reset()                    { *m = ScanResponse{} }
func (m *ScanResponse) String() string            { return proto.CompactTextString(m) }
func (*ScanResponse) ProtoMessage()               {}
func (*ScanResponse) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{3} }

func (m *ScanResponse) GetCode() ResultCode {
	if m != nil {
		return m.Code
	}
	return ResultCode_OK
}

type ScanCompleted struct {
	// ID of the calling analyzer run
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Base path for scan result
	Path string `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
}

func (m *ScanCompleted) Reset()                    { *m = ScanCompleted{} }
func (m *ScanCompleted) String() string            { return proto.CompactTextString(m) }
func (*ScanCompleted) ProtoMessage()               {}
func (*ScanCompleted) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{4} }

func (m *ScanCompleted) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ScanCompleted) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

type JobStatus struct {
	// ID of the analyzer run
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Current scan/analyzer status
	Status Status `protobuf:"varint,2,opt,name=status,proto3,enum=busapi.Status" json:"status,omitempty"`
	// Optional description i.e. for certain scan stages
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// Approximated percent completed
	Completed uint32 `protobuf:"varint,4,opt,name=completed,proto3" json:"completed,omitempty"`
}

func (m *JobStatus) Reset()                    { *m = JobStatus{} }
func (m *JobStatus) String() string            { return proto.CompactTextString(m) }
func (*JobStatus) ProtoMessage()               {}
func (*JobStatus) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{5} }

func (m *JobStatus) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *JobStatus) GetStatus() Status {
	if m != nil {
		return m.Status
	}
	return Status_READY
}

func (m *JobStatus) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *JobStatus) GetCompleted() uint32 {
	if m != nil {
		return m.Completed
	}
	return 0
}

func init() {
	proto.RegisterType((*AnalyserRequest)(nil), "busapi.AnalyserRequest")
	proto.RegisterType((*AnalyserResponse)(nil), "busapi.AnalyserResponse")
	proto.RegisterType((*ScanRequest)(nil), "busapi.ScanRequest")
	proto.RegisterType((*ScanResponse)(nil), "busapi.ScanResponse")
	proto.RegisterType((*ScanCompleted)(nil), "busapi.ScanCompleted")
	proto.RegisterType((*JobStatus)(nil), "busapi.JobStatus")
	proto.RegisterEnum("busapi.ResultCode", ResultCode_name, ResultCode_value)
	proto.RegisterEnum("busapi.Status", Status_name, Status_value)
	proto.RegisterEnum("busapi.Scanner", Scanner_name, Scanner_value)
}
func (m *AnalyserRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnalyserRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Domain) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Domain)))
		i += copy(dAtA[i:], m.Domain)
	}
	if m.Scanner != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Scanner))
	}
	return i, nil
}

func (m *AnalyserResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnalyserResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	return i, nil
}

func (m *ScanRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScanRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Domain) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Domain)))
		i += copy(dAtA[i:], m.Domain)
	}
	return i, nil
}

func (m *ScanResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScanResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
	}
	return i, nil
}

func (m *ScanCompleted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScanCompleted) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Path) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	return i, nil
}

func (m *JobStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Status))
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.Completed != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Completed))
	}
	return i, nil
}

func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AnalyserRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Domain)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Scanner != 0 {
		n += 1 + sovApi(uint64(m.Scanner))
	}
	return n
}

func (m *AnalyserResponse) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *ScanRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Domain)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *ScanResponse) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	return n
}

func (m *ScanCompleted) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *JobStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovApi(uint64(m.Status))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Completed != 0 {
		n += 1 + sovApi(uint64(m.Completed))
	}
	return n
}

func sovApi(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AnalyserRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnalyserRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnalyserRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scanner", wireType)
			}
			m.Scanner = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Scanner |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnalyserResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnalyserResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnalyserResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (ResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScanRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScanRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScanRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScanResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScanResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScanResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (ResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScanCompleted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScanCompleted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScanCompleted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Completed", wireType)
			}
			m.Completed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Completed |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowApi
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipApi(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthApi = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("api.proto", fileDescriptorApi) }

var fileDescriptorApi = []byte{
	// 422 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x52, 0x3f, 0x6f, 0x9b, 0x40,
	0x14, 0xf7, 0x11, 0x8a, 0xc3, 0xb3, 0x4d, 0x4e, 0x37, 0x54, 0x0c, 0x95, 0x65, 0x31, 0x44, 0x91,
	0x07, 0x0f, 0x8e, 0xda, 0x9d, 0xda, 0xa4, 0x25, 0x4d, 0x21, 0x3a, 0x68, 0xab, 0x74, 0x3b, 0xc3,
	0x49, 0x45, 0x72, 0x38, 0xea, 0x3b, 0x0f, 0x9d, 0xfb, 0xe5, 0x3a, 0xf6, 0x23, 0x54, 0xfe, 0x24,
	0xd5, 0x1d, 0x20, 0x5b, 0xf2, 0x94, 0x8d, 0xdf, 0xfb, 0xbd, 0xdf, 0x1f, 0x4e, 0x0f, 0x5c, 0xd6,
	0x54, 0x8b, 0x66, 0x27, 0x94, 0x20, 0xce, 0x66, 0x2f, 0x59, 0x53, 0x05, 0x2b, 0xb8, 0x0a, 0x6b,
	0xb6, 0xfd, 0x25, 0xf9, 0x8e, 0xf2, 0x9f, 0x7b, 0x2e, 0x15, 0x79, 0x0d, 0x4e, 0x29, 0x9e, 0x59,
	0x55, 0xfb, 0x68, 0x86, 0x6e, 0x5c, 0xda, 0x21, 0xe2, 0xc3, 0x50, 0x16, 0xac, 0xae, 0xf9, 0xce,
	0xb7, 0x66, 0xe8, 0x66, 0x42, 0x7b, 0x18, 0xdc, 0x03, 0x3e, 0x9a, 0xc8, 0x46, 0xd4, 0x92, 0x93,
	0x6b, 0xb0, 0x0b, 0x51, 0x72, 0xe3, 0xe1, 0x2d, 0xc9, 0xa2, 0xcd, 0x5b, 0x50, 0x2e, 0xf7, 0x5b,
	0xb5, 0x12, 0x25, 0xa7, 0x86, 0x27, 0x1e, 0x58, 0x55, 0x69, 0x0c, 0x5d, 0x6a, 0x55, 0x65, 0xf0,
	0x16, 0x46, 0x59, 0xc1, 0xea, 0xbe, 0x4c, 0x4b, 0xa3, 0x9e, 0x3e, 0x29, 0x67, 0x9d, 0x96, 0x0b,
	0xde, 0xc1, 0xb8, 0x95, 0xbd, 0x2c, 0x3e, 0xb8, 0x85, 0x89, 0xd6, 0xad, 0xc4, 0x73, 0xb3, 0xe5,
	0x8a, 0x97, 0x67, 0x81, 0x04, 0xec, 0x86, 0xa9, 0x1f, 0x5d, 0x9c, 0xf9, 0x0e, 0x7e, 0x23, 0x70,
	0xef, 0xc5, 0x26, 0x53, 0x4c, 0xed, 0xe5, 0x99, 0xe2, 0x1a, 0x1c, 0x69, 0x18, 0xa3, 0xf1, 0x96,
	0x5e, 0x1f, 0xde, 0xee, 0xd3, 0x8e, 0x25, 0x33, 0x18, 0x95, 0x5c, 0x16, 0xbb, 0xaa, 0x51, 0x95,
	0xa8, 0xfd, 0x0b, 0x63, 0x70, 0x3a, 0x22, 0x6f, 0xc0, 0x2d, 0xfa, 0x62, 0xbe, 0x6d, 0xde, 0xfc,
	0x38, 0x98, 0x4f, 0x01, 0x8e, 0xbf, 0x43, 0x1c, 0xb0, 0xd2, 0x4f, 0x78, 0x40, 0x2e, 0xc1, 0xbe,
	0x0b, 0xe3, 0x07, 0x8c, 0xe6, 0x1b, 0x70, 0xba, 0x86, 0x2e, 0xbc, 0xa2, 0x51, 0xb8, 0x7e, 0xc2,
	0x03, 0x32, 0x82, 0xe1, 0x63, 0x94, 0xac, 0xe3, 0xe4, 0x03, 0x46, 0x1a, 0x7c, 0x0b, 0xe3, 0x5c,
	0x03, 0x8b, 0x8c, 0xe1, 0x32, 0x5b, 0x85, 0x49, 0xa2, 0xd1, 0x05, 0x99, 0x80, 0x1b, 0x26, 0xe1,
	0xc3, 0xd3, 0x77, 0x0d, 0x6d, 0xbd, 0x99, 0xc7, 0x9f, 0xa3, 0xf4, 0x4b, 0x8e, 0x3d, 0x6d, 0x17,
	0x51, 0x9a, 0x52, 0x7c, 0x35, 0x5f, 0xc2, 0x30, 0x6b, 0x8f, 0x40, 0x07, 0x27, 0x69, 0x12, 0xe1,
	0x81, 0xd6, 0x7e, 0x0c, 0xe9, 0xd7, 0x28, 0xcb, 0x23, 0x8a, 0x11, 0xf1, 0x00, 0xb2, 0xc7, 0x78,
	0x1d, 0xd1, 0xbb, 0x34, 0xcd, 0xb1, 0xf5, 0x7e, 0xfc, 0xe7, 0x30, 0x45, 0x7f, 0x0f, 0x53, 0xf4,
	0xef, 0x30, 0x45, 0x1b, 0xc7, 0xdc, 0xe3, 0xed, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x68, 0x6f,
	0xec, 0x65, 0x9c, 0x02, 0x00, 0x00,
}
